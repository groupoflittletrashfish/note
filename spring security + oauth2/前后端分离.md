<head>
  <style>
    .c{
      font-size: 14px;
    }
    hl{
      background:#3E74;
      display:inline-block;
      padding:1px
    }
  </style>
</head>

<font class= 'c'>

[toc]

## 前后端分离下的 授权认证
* 此篇是归纳总结
## 流程图
![](./pic/认证授权流程图.png)


## 直接上代码
### 认证服务器
* pom文件依赖，有点多很多没用的，可以删除
    ~~~xml
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <groupId>com.noname</groupId>
        <artifactId>oauth2_demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <name>oauth2_demo</name>
        <description>Demo project for Spring Boot</description>

        <properties>
            <java.version>1.8</java.version>
            <spring-boot.version>2.4.4</spring-boot.version>
            <spring-cloud.version>2020.0.2</spring-cloud.version>
            <spring-cloud-alibaba.version>2020.0.RC1</spring-cloud-alibaba.version>
            <mybatis-plus-version>3.2.0</mybatis-plus-version>
            <swagger.version>3.0.0</swagger.version>
        </properties>

        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-oauth2</artifactId>
                <version>2.2.5.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-security</artifactId>
                <version>2.2.0.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-redis</artifactId>
                <version>2.5.5</version>
            </dependency>
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-openfeign</artifactId>
            </dependency>
            <dependency>
                <groupId>com.yongzheng</groupId>
                <artifactId>yz_common</artifactId>
                <version>0.0.1-SNAPSHOT</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-loadbalancer</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-test</artifactId>
                <scope>test</scope>
            </dependency>
            <!--注册中心客户端-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
            </dependency>
            <!--配置中心客户端-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-thymeleaf</artifactId>
            </dependency>
            <dependency>
                <groupId>org.thymeleaf.extras</groupId>
                <artifactId>thymeleaf-extras-springsecurity5</artifactId>
            </dependency>
            <dependency>
                <groupId>com.github.penggle</groupId>
                <artifactId>kaptcha</artifactId>
                <version>2.3.2</version>
            </dependency>
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.76</version>
            </dependency>
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <scope>runtime</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-jdbc</artifactId>
            </dependency>
            <!--        阿里短信接口-->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>dysmsapi20170525</artifactId>
                <version>2.0.9</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-redis</artifactId>
                <version>2.1.3.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>com.yongzheng</groupId>
                <artifactId>yz_swagger</artifactId>
                <version>0.0.1-SNAPSHOT</version>
            </dependency>
        </dependencies>

        <dependencyManagement>
            <dependencies>
                <!-- spring boot 依赖 -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-dependencies</artifactId>
                    <version>${spring-boot.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!-- spring cloud 依赖 -->
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
                <!-- spring cloud alibaba 依赖 -->
                <dependency>
                    <groupId>com.alibaba.cloud</groupId>
                    <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                    <version>${spring-cloud-alibaba.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
            </dependencies>
        </dependencyManagement>

        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.8.1</version>
                    <configuration>
                        <source>1.8</source>
                        <target>1.8</target>
                        <encoding>UTF-8</encoding>
                    </configuration>
                </plugin>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>2.3.7.RELEASE</version>
                    <configuration>
                        <mainClass>com.noname.oauth2_demo.Oauth2DemoApplication</mainClass>
                    </configuration>
                    <executions>
                        <execution>
                            <id>repackage</id>
                            <goals>
                                <goal>repackage</goal>
                            </goals>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>

    </project>

    ~~~

* 配置文件
    ~~~yaml
    server:
    port: 8099
    spring:
    application:
        name: oauth2-demo
    profiles:
        active: dev
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3306/yz_demo?useUnicode=true&characterEncoding=UTF-8&useSSL=false
        username: root
        password: root
    ~~~
* 数据库表
    ~~~sql
    /*
    Navicat Premium Data Transfer

    Source Server         : 本地
    Source Server Type    : MySQL
    Source Server Version : 50736
    Source Host           : localhost:3306
    Source Schema         : yz_demo

    Target Server Type    : MySQL
    Target Server Version : 50736
    File Encoding         : 65001

    Date: 08/06/2022 16:48:32
    */

    SET NAMES utf8mb4;
    SET FOREIGN_KEY_CHECKS = 0;

    -- ----------------------------
    -- Table structure for oauth_client_details
    -- ----------------------------
    DROP TABLE IF EXISTS `oauth_client_details`;
    CREATE TABLE `oauth_client_details`  (
    `client_id` varchar(48) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
    `resource_ids` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `client_secret` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `scope` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `authorized_grant_types` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `web_server_redirect_uri` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `authorities` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `access_token_validity` int(11) NULL DEFAULT NULL,
    `refresh_token_validity` int(11) NULL DEFAULT NULL,
    `additional_information` varchar(4096) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    `autoapprove` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
    PRIMARY KEY (`client_id`) USING BTREE
    ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

    -- ----------------------------
    -- Records of oauth_client_details
    -- ----------------------------
    INSERT INTO `oauth_client_details` VALUES ('binbin', NULL, '$2a$10$RpFJjxYiXdEsAGnWp/8fsOetMuOON96Ntk/Ym2M/RKRyU0GZseaDC', 'all', 'authorization_code', NULL, 'ROLE_ADMIN', 3600, NULL, NULL, 'true');
    INSERT INTO `oauth_client_details` VALUES ('noname', NULL, '$2a$10$RpFJjxYiXdEsAGnWp/8fsOetMuOON96Ntk/Ym2M/RKRyU0GZseaDC', 'all', 'password,refresh_token', 'http://localhost:8083/login', NULL, 3600, NULL, NULL, 'true');

    SET FOREIGN_KEY_CHECKS = 1;

    ~~~
* 启动类添加注解 @EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
    ~~~java
    @SpringBootApplication
    @EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
    public class Oauth2DemoApplication {

        public static void main(String[] args) {
            SpringApplication.run(Oauth2DemoApplication.class, args);
        }

    }
    ~~~
* 重写UserDetailsService,也就是自己的登录逻辑，此处demo直接写死
    ~~~java
    @Service
    @RequiredArgsConstructor(onConstructor = @__(@Autowired))
    public class UserDetailsServiceImpl implements UserDetailsService {

        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            //此处的密码是123456
            return new User("admin", "$2a$10$RpFJjxYiXdEsAGnWp/8fsOetMuOON96Ntk/Ym2M/RKRyU0GZseaDC", AuthorityUtils.commaSeparatedStringToAuthorityList("ROLE_ADMIN"));
        }
    }
    ~~~

* 指定token为jwt
    ~~~java
    @Configuration
    public class JwtTokenStoreConfig {


        @Bean
        public TokenStore jwtTokenStore() {
            return new JwtTokenStore(jwtAccessTokenConverter());
        }


        @Bean
        public JwtAccessTokenConverter jwtAccessTokenConverter() {
            JwtAccessTokenConverter accessTokenConverter = new JwtAccessTokenConverter();
            //配置JWT的使用密钥
            accessTokenConverter.setSigningKey("test_key");
            return accessTokenConverter;
        }

    }
    ~~~

* Security的主配置文件
    ~~~java
    @Configuration
    @RequiredArgsConstructor(onConstructor = @__(@Autowired))
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {

        private final UserDetailsService userDetailsService;

        @Bean
        public PasswordEncoder getPw() {
            return new BCryptPasswordEncoder();
        }

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf().disable().authorizeRequests()
                    .antMatchers("/oauth/**", "/login/**,/logout/**").permitAll()
                    .anyRequest().authenticated()
                    //and()没什么实际意义，只是一个连接符
                    .and()
                    //所有表单都放行
                    .formLogin().permitAll();
        }


        @Bean
        public CorsFilter corsFilter() {
            UrlBasedCorsConfigurationSource configurationSource = new UrlBasedCorsConfigurationSource();
    //        CorsConfiguration cors = new CorsConfiguration();
    //        cors.setAllowCredentials(true);
    //        cors.addAllowedOriginPattern("*");
    //        cors.addAllowedHeader("*");
    //        cors.addAllowedMethod("*");
    //        configurationSource.registerCorsConfiguration("/**", cors);
            return new CorsFilter(configurationSource);
        }

        @Bean
        @Override
        public AuthenticationManager authenticationManagerBean() throws Exception {
            return super.authenticationManagerBean();
        }

    }
    ~~~

* 认证服务器配置
    ~~~java
    @Configuration
    @EnableAuthorizationServer
    @RequiredArgsConstructor
    public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {

        private final DataSource dataSource;
        private final UserDetailsServiceImpl userService;
        private final AuthenticationManager authenticationManager;
        private final TokenStore tokenStore;
        private final JwtAccessTokenConverter jwtAccessTokenConverter;

        @Override
        public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
            clients.withClientDetails(clientDetails());
        }

        /**
        * 密码模式必须
        */
        @Override
        public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
            security.tokenKeyAccess("isAuthenticated()");
        }


        @Bean
        public ClientDetailsService clientDetails() {
            //这一段是关键，Security提供了对JDBC的支持
            return new JdbcClientDetailsService(dataSource);
        }

        @Override
        public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
            endpoints.authenticationManager(authenticationManager)
                    //指定自定义的登录逻辑
                    .userDetailsService(userService)
                    //指定使用jwt
                    .tokenStore(tokenStore)
                    //jwt的转换
                    .accessTokenConverter(jwtAccessTokenConverter);
        }
    }
    ~~~
* <hl>认的异常返回其实是很不人性化的，所以在后面的章节会介绍认证端的自定义异常处理</hl>

### 子应用
* 新建一个项目，来作为子服务，pom文件使用上面的即可
* 配置文件如下：
    ~~~yaml
    server:
    port: 8083
    servlet:
        session:
        cookie:
            #防止cookie冲突，冲突会导致登录验证不通过
            name: OAUTH2-CLIENT-SESSIONID01
    # 授权服务器的地址，供下面的配置文件使用
    oauth2-server-url: http://localhost:8099
    # 与授权服务器对应的配置
    security:
    oauth2:
        client:
        client-id: noname
        client-secret: 123456
        # 授权URI
        user-authorization-uri: ${oauth2-server-url}/oauth/authorize
        # 获取token的URI
        access-token-uri: ${oauth2-server-url}/oauth/token
        resource:
        jwt:
            # 获取jwt的URI
            key-uri: ${oauth2-server-url}/oauth/token_key
    spring:
    application:
        name: demo
    ~~~
* 启动类添加注解,主要要使用 EnableResourceServer 注解，因为后端不需要跳转到登录页面
    ~~~java
    @SpringBootApplication
    @EnableResourceServer
    @EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
    public class Oauth2client01DemoApplication {

        public static void main(String[] args) {
            SpringApplication.run(Oauth2client01DemoApplication.class, args);
        }

    }
    ~~~

* 提供一个测试的接口
    ~~~java
    @RestController
    @RequestMapping("/user")
    public class UserController {

        /**
        * 获取用户信息
        *
        * @param authentication
        * @return
        */
        @RequestMapping("/getCurrentUser")
        @PreAuthorize("hasRole('888')")
        public Object getCurrentUser(Authentication authentication) {
            return authentication;
        }

    }
    ~~~
* 子服务配置完成，前端可以直接调用/oauth/token来获取token,如何调用可以参看本文件夹下 spring security+oauth2.md 中的密码模式，授权码模式暂时没有测试
* 返回的token格式如下：
    ~~~json
    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTQ2ODIzOTIsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsiUk9MRV9BRE1JTiJdLCJqdGkiOiIyZWEzYTQwZi0wYWNhLTQ5N2EtOTQ0YS0xN2JhYTc4Njg1OTciLCJjbGllbnRfaWQiOiJub25hbWUiLCJzY29wZSI6WyJhbGwiXX0.98apAMtokauRE2lpSvt697melD0dZ21hlsfYRngZ1Uk",
        "token_type": "bearer",
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiIyZWEzYTQwZi0wYWNhLTQ5N2EtOTQ0YS0xN2JhYTc4Njg1OTciLCJleHAiOjE2NTcyNzA3OTIsImF1dGhvcml0aWVzIjpbIlJPTEVfQURNSU4iXSwianRpIjoiMmVhYmEzNzItMzNhZS00MDI4LThmNDItOGYzYWY3ODdhYjBhIiwiY2xpZW50X2lkIjoibm9uYW1lIn0.nxScjhOEM8sCvOyhMpa6ADYp5tjZHLx-wiGpKO9osVg",
        "expires_in": 3599,
        "scope": "all",
        "jti": "2ea3a40f-0aca-497a-944a-17baa7868597"
    }
    ~~~
* 然后测试前端带着这个token去调用测试接口即可：http://localhost:8083/user/getCurrentUser
* Oauth2提供的异常很丑陋，可以自己重新定义，在子应用中添加自定义异常的两个类，直接提供代码
    ~~~java
    @Data
    public class R<T> {

        private static final long serialVersionUID = -9054533633223096638L;
        private int code;
        private String msg;
        private T data;

        public static <T> R<T> ok(T data) {
            R<T> result = new R<>();
            result.setCode(200);
            result.setMsg("success");
            result.setData(data);
            return result;
        }


        public static <T> R<T> ok() {
            return ok(null);
        }


        public static <T> R<T> error(int code, String msg) {
            R<T> result = new R<>();
            result.setCode(code);
            result.setMsg(msg);
            return result;
        }


        public static <T> R<T> error(String msg) {
            R<T> result = new R<>();
            result.setCode(500);
            result.setMsg(msg);
            return result;
        }
    }
    ~~~
    ~~~java
    @Component
    public class MyExtendAccessDeniedHandler implements AccessDeniedHandler {


        @Override
        public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {

            // 自定义返回格式内容
            System.out.println("Oauth2抛出的异常消息：" + accessDeniedException.getMessage());
            response.setStatus(HttpStatus.OK.value());
            response.setCharacterEncoding("utf-8");
            response.setHeader("Content-Type", "application/json;charset=UTF-8");
            response.setStatus(HttpStatus.FORBIDDEN.value());// 权限不足403
            response.getWriter().write(new ObjectMapper().writeValueAsString(R.error(403, "没有访问权限")));

        }
    }
    ~~~
    ~~~java
    @Component
    public class MyExtendAuthenticationEntryPointHandler extends OAuth2AuthenticationEntryPoint {


        @Override
        public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException {

            Throwable cause = authException.getCause();
            System.out.println("Oauth2抛出的异常：" + authException.getMessage());

            //自定义返回格式内容
            R<?> r = new R<>();
            r.setCode(401);

            if (cause instanceof OAuth2AccessDeniedException) {
                r.setMsg("资源ID不在resource_ids范围内");
            } else if (cause instanceof InvalidTokenException) {
                r.setMsg("Token解析失败");
            } else if (authException instanceof InsufficientAuthenticationException) {
                r.setMsg("未携带token");
            } else {
                r.setMsg("未知异常信息");
            }

            response.setStatus(HttpStatus.OK.value());
            response.setCharacterEncoding("utf-8");
            response.setHeader("Content-Type", "application/json;charset=UTF-8");
            PrintWriter printWriter = response.getWriter();
            printWriter.append(new ObjectMapper().writeValueAsString(r));

        }

    }
    ~~~
* 接下来就是新建一个资源服务器的配置类来使用自定义的异常返回机制
    ~~~java
    @RequiredArgsConstructor
    @Configuration
    public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {

        private final MyExtendAccessDeniedHandler myExtendAccessDeniedHandler;
        private final MyExtendAuthenticationEntryPointHandler myExtendAuthenticationEntryPointHandler;

        @Override
        public void configure(ResourceServerSecurityConfigurer resources) {
            resources.authenticationEntryPoint(myExtendAuthenticationEntryPointHandler).accessDeniedHandler(myExtendAccessDeniedHandler);
        }
    }
    ~~~
* 再次访问即可。

## 认证端异常处理
* 也就是认证服务器需要特殊的处理，直接上四个类
    ~~~java
    import com.fasterxml.jackson.databind.annotation.JsonSerialize;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.security.oauth2.common.exceptions.OAuth2Exception;

    import java.util.concurrent.ConcurrentHashMap;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/6/9 11:17
    * @description ：OAuth2的错误信息处理
    * @modified By：
    * @version: 1.0
    */
    @JsonSerialize(using = MyExtendOAuth2ExceptionSerializer.class)
    @Slf4j
    public class MyExtendOAuth2Exception extends OAuth2Exception {
        /**
        * OAuth2Exception
        */
        public static final String ERROR = "error";
        public static final String DESCRIPTION = "error_description";
        public static final String URI = "error_uri";
        public static final String INVALID_REQUEST = "invalid_request";
        public static final String INVALID_CLIENT = "invalid_client";
        public static final String INVALID_GRANT = "invalid_grant";
        public static final String UNAUTHORIZED_CLIENT = "unauthorized_client";
        public static final String UNSUPPORTED_GRANT_TYPE = "unsupported_grant_type";
        public static final String INVALID_SCOPE = "invalid_scope";
        public static final String INSUFFICIENT_SCOPE = "insufficient_scope";
        public static final String INVALID_TOKEN = "invalid_token";
        public static final String REDIRECT_URI_MISMATCH = "redirect_uri_mismatch";
        public static final String UNSUPPORTED_RESPONSE_TYPE = "unsupported_response_type";
        public static final String ACCESS_DENIED = "access_denied";
        /**
        * 其他异常
        */
        public static final String METHOD_NOT_ALLOWED = "method_not_allowed";
        public static final String SERVER_ERROR = "server_error";
        public static final String UNAUTHORIZED = "unauthorized";

        private static ConcurrentHashMap<String, String> oAuth2ErrorMap = new ConcurrentHashMap<>();

        /**
        * 映射了一部分
        */
        static {
            oAuth2ErrorMap.put(INVALID_CLIENT, "无效的客户端");
            oAuth2ErrorMap.put(INVALID_GRANT, "用户名或者密码错误");
            oAuth2ErrorMap.put(INVALID_SCOPE, "权限不足");
            oAuth2ErrorMap.put(UNSUPPORTED_GRANT_TYPE, "不支持的授权模式类型");
            oAuth2ErrorMap.put(ACCESS_DENIED, "拒绝访问");

            oAuth2ErrorMap.put(METHOD_NOT_ALLOWED, "方法不允许访问");
            oAuth2ErrorMap.put(SERVER_ERROR, "服务器内部异常");
            oAuth2ErrorMap.put(UNAUTHORIZED, "未授权");
            oAuth2ErrorMap.put(UNAUTHORIZED_CLIENT, "未授权的资源");
        }

        /**
        * oAuth2ErrorCode的扩展信息
        */
        private String myExtendMessage;

        public MyExtendOAuth2Exception(String msg, Throwable t) {
            super(msg, t);
        }

        public MyExtendOAuth2Exception(String msg, String oAuth2ErrorCode, Throwable t) {
            super(msg, t);
            log.info("自定义扩展OAuth2异常处理 MyExtendOAuth2Exception.class -> msg={}，oAuth2ErrorCode={}", msg, oAuth2ErrorCode);
            String oAuth2ErrorMessage = oAuth2ErrorMap.get(oAuth2ErrorCode);
            this.myExtendMessage = oAuth2ErrorMessage != null ? oAuth2ErrorMessage : "未知异常：" + oAuth2ErrorCode;
        }

        public String getMyExtendMessage() {
            return myExtendMessage;
        }

        public void setMyExtendMessage(String myExtendMessage) {
            this.myExtendMessage = myExtendMessage;
        }
    }
    ~~~
    ~~~java
    import com.fasterxml.jackson.core.JsonGenerator;
    import com.fasterxml.jackson.databind.SerializerProvider;
    import com.fasterxml.jackson.databind.ser.std.StdSerializer;
    import com.yongzheng.dto.R;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.stereotype.Component;

    import java.io.IOException;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/6/9 11:23
    * @description ：
    * @modified By：
    * @version:
    */
    @Component
    @Slf4j
    public class MyExtendOAuth2ExceptionSerializer extends StdSerializer<MyExtendOAuth2Exception> {

        public MyExtendOAuth2ExceptionSerializer() {
            super(MyExtendOAuth2Exception.class);
        }

        @Override
        public void serialize(MyExtendOAuth2Exception e, JsonGenerator jGen, SerializerProvider provider) throws IOException {
            log.info("MyCustomOAuth2Exception返回格式序列化处理，MyExtendOAuth2ExceptionSerializer.class -> e={}", e);
            // 自定义返回格式内容
            log.error("Oauth的错误信息：" + e.getMessage());
            jGen.writeObject(R.error(e.getMyExtendMessage()));
        }
    }

    ~~~
    ~~~java
    import org.springframework.http.HttpHeaders;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.oauth2.common.DefaultThrowableAnalyzer;
    import org.springframework.security.oauth2.common.OAuth2AccessToken;
    import org.springframework.security.oauth2.common.exceptions.InsufficientScopeException;
    import org.springframework.security.oauth2.common.exceptions.OAuth2Exception;
    import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;
    import org.springframework.security.web.util.ThrowableAnalyzer;
    import org.springframework.stereotype.Component;

    import java.io.IOException;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/6/9 11:14
    * @description ：异常解释器
    * @modified By：
    * @version: 1.0
    */
    @Component
    public class MyExtendOAuth2ResponseExceptionTranslator implements WebResponseExceptionTranslator<OAuth2Exception> {

        private ThrowableAnalyzer throwableAnalyzer = new DefaultThrowableAnalyzer();

        @Override
        public ResponseEntity<OAuth2Exception> translate(Exception e) throws Exception {

            // Try to extract a SpringSecurityException from the stacktrace
            Throwable[] causeChain = throwableAnalyzer.determineCauseChain(e);
            // 异常栈获取 OAuth2Exception 异常
            Exception ase = (OAuth2Exception) throwableAnalyzer.getFirstThrowableOfType(OAuth2Exception.class, causeChain);
            if (ase != null) {
                return handleOAuth2Exception((OAuth2Exception) ase);
            }

            // 否则服务器内部错误
            return handleOAuth2Exception(new ServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), e));

        }

        private ResponseEntity<OAuth2Exception> handleOAuth2Exception(OAuth2Exception e) throws IOException {
            int status = e.getHttpErrorCode();
            HttpHeaders headers = new HttpHeaders();
            headers.set("Cache-Control", "no-store");
            headers.set("Pragma", "no-cache");
            if (status == HttpStatus.UNAUTHORIZED.value() || (e instanceof InsufficientScopeException)) {
                headers.set("WWW-Authenticate", String.format("%s %s", OAuth2AccessToken.BEARER_TYPE, e.getSummary()));
            }

            // 使用自定义扩展OAuth2Exception
            e = new MyExtendOAuth2Exception(e.getMessage(), e.getOAuth2ErrorCode(), e);
            ResponseEntity<OAuth2Exception> response = new ResponseEntity<OAuth2Exception>(e, headers, HttpStatus.valueOf(status));
            return response;
        }


    }

    ~~~
    ~~~java
    import org.springframework.http.HttpStatus;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/6/9 11:21
    * @description ：
    * @modified By：
    * @version:
    */
    public class ServerErrorException extends MyExtendOAuth2Exception {

        public ServerErrorException(String msg, Throwable t) {
            super(msg, t);
        }

        @Override
        public String getOAuth2ErrorCode() {
            return "server_error";
        }

        @Override
        public int getHttpErrorCode() {
            return HttpStatus.INTERNAL_SERVER_ERROR.value();
        }
    }
    ~~~
* 最后需要在AuthorizationServerConfig，也就是认证服务的配置类中添加如下
    ~~~java
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
            endpoints.authenticationManager(authenticationManager)
                    //指定自定义的登录逻辑
                    .userDetailsService(userService)
                    //指定使用jwt
                    .tokenStore(tokenStore)
                    //jwt的转换
                    .accessTokenConverter(jwtAccessTokenConverter);
                    //添加自定义的解释器
            endpoints.exceptionTranslator(new MyExtendOAuth2ResponseExceptionTranslator());
        }
    ~~~
* 这样就完成了，完成后就可以生效了，但是如果是/oauth/token接口去获取token的时候，如果是client_id这个参数错误，还是会抛出如下
    ~~~json
    {
        "error": "unauthorized",
        "error_description": "Full authentication is required to access this resource"
    }
    ~~~
* 暂时没找到对应的修改方法

## /oauth/token 返回结果封装
* 网上给出的方式是使用AOP，直接上代码
    ~~~java
    import com.yongzheng.dto.R;
    import lombok.extern.slf4j.Slf4j;
    import org.aspectj.lang.ProceedingJoinPoint;
    import org.aspectj.lang.annotation.Around;
    import org.aspectj.lang.annotation.Aspect;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.authentication.InsufficientAuthenticationException;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.oauth2.common.OAuth2AccessToken;
    import org.springframework.security.oauth2.common.util.OAuth2Utils;
    import org.springframework.security.oauth2.provider.OAuth2Authentication;
    import org.springframework.stereotype.Component;

    import java.security.Principal;
    import java.util.Map;
    /**
    * @author ：liwuming
    * @date ：Created in 2022/6/9 15:58
    * @description ：Oauth的返回格式自定义
    * @modified By：
    * @version: 1.0
    */
    @Slf4j
    @Component
    @Aspect
    public class OauthTokenAspect {

        @Around("execution(* org.springframework.security.oauth2.provider.endpoint.TokenEndpoint.postAccessToken(..))")
        public Object handleControllerMethod(ProceedingJoinPoint joinPoint) throws Throwable {
            try {
                Object[] args = joinPoint.getArgs();
                Principal principal = (Principal) args[0];
                if (!(principal instanceof Authentication)) {
                    throw new InsufficientAuthenticationException("There is no client authentication. Try adding an appropriate authentication filter.");
                }
                String clientId = this.getClientId(principal);
                Map<String, String> parameters = (Map<String, String>) args[1];
                String grantType = parameters.get(OAuth2Utils.GRANT_TYPE);

                Object proceed = joinPoint.proceed();
                if ("authorization_code".equals(grantType)) {
                    /**
                    * 如果使用 @EnableOAuth2Sso 注解不能修改返回格式，否则授权码模式可以统一改
                    * 因为本项目的 sso-demo/ss-sso 里面使用了 @EnableOAuth2Sso 注解，所以这里就不修改授权码模式的token返回值了
                    */
                    return proceed;
                } else {
                    ResponseEntity<OAuth2AccessToken> responseEntity = (ResponseEntity<OAuth2AccessToken>) proceed;
                    OAuth2AccessToken body = responseEntity.getBody();
                    return ResponseEntity
                            .status(HttpStatus.OK)
                            .body(R.ok(body));
                }
            } finally {

            }
        }

        private String getClientId(Principal principal) {
            Authentication client = (Authentication) principal;
            if (!client.isAuthenticated()) {
                throw new InsufficientAuthenticationException("The client is not authenticated.");
            }
            String clientId = client.getName();
            if (client instanceof OAuth2Authentication) {
                clientId = ((OAuth2Authentication) client).getOAuth2Request().getClientId();
            }
            return clientId;
        }
    }
    ~~~
* 此时的返回数据结果就被封装了一层
    ~~~json
    {
        "code": 200,
        "msg": "success",
        "data": {
            "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTQ3NjcwNjcsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsic3lzX21lbnVfZWRpdCIsInN5c19yb2xlX2VkaXQiLCJzeXNfcm9sZV9wZXJtIiwic3lzX21lbnVfYWRkIiwic3lzX3JvbGVfYWRkIiwic3lzX3VzZXJfYWRkIiwiUk9MRV9BRE1JTiIsInN5c19tZW51X2RlbCIsInN5c19yb2xlX2RlbCJdLCJqdGkiOiJhMWU0YzczMC1lMGFmLTQ5MWEtOTg1Mi1mOTc4OTdlNDkwMzkiLCJjbGllbnRfaWQiOiJub25hbWUiLCJzY29wZSI6WyJhbGwiXX0.Q9iYtpdNtdUzZ1lfXGJu-cSSPYq-xSPVrgN2Ybd0vP8",
            "token_type": "bearer",
            "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJhMWU0YzczMC1lMGFmLTQ5MWEtOTg1Mi1mOTc4OTdlNDkwMzkiLCJleHAiOjE2NTczNTU0NjcsImF1dGhvcml0aWVzIjpbInN5c19tZW51X2VkaXQiLCJzeXNfcm9sZV9lZGl0Iiwic3lzX3JvbGVfcGVybSIsInN5c19tZW51X2FkZCIsInN5c19yb2xlX2FkZCIsInN5c191c2VyX2FkZCIsIlJPTEVfQURNSU4iLCJzeXNfbWVudV9kZWwiLCJzeXNfcm9sZV9kZWwiXSwianRpIjoiZGY0OWE4YjYtMGRiNC00OTQ4LWI3NjItYzk4YjY2MTZjNjRmIiwiY2xpZW50X2lkIjoibm9uYW1lIn0.2n9z7sB_-Wa0bdVatWqET3PljEPiJsHWyN8zwthz7vE",
            "expires_in": 3571,
            "scope": "all",
            "jti": "a1e4c730-e0af-491a-9852-f97897e49039"
        }
    }
    ~~~

## 动态URL拦截
* 即根据URL直接去拦截来判断权限，这个其实在spring security+oauth2.md中讲过，只不过是放在了资源服务器中，也就是子应用，直接把两个类复制过来即可。
    ~~~java
    package com.yongzheng.config.dynamicInterception;

    import com.yongzheng.feign.AdminClient;
    import lombok.RequiredArgsConstructor;
    import org.apache.commons.lang3.StringUtils;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.access.ConfigAttribute;
    import org.springframework.security.access.SecurityConfig;
    import org.springframework.security.web.FilterInvocation;
    import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource;
    import org.springframework.stereotype.Component;
    import org.springframework.util.AntPathMatcher;
    import org.springframework.web.util.UrlPathHelper;

    import javax.servlet.http.HttpServletRequest;
    import java.util.Collection;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/3/9 15:07
    * @description ：动态拦截
    * @modified By：
    * @version: 1.0
    */
    @Component
    @RequiredArgsConstructor(onConstructor = @__(@Autowired))
    public class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource {

        private final AdminClient adminClient;
        private final AntPathMatcher antPathMatcher = new AntPathMatcher();

        @Override
        public Collection<ConfigAttribute> getAttributes(Object o) throws IllegalArgumentException {
            //客户端请求的Url
            String requestUrl = ((FilterInvocation) o).getRequest().getRequestURI();
            //如果地址是如下，那么设置一个自定义的标识，表示可以匿名访问,也就是说不需要登录也可以访问
            if (isIgnore(((FilterInvocation) o).getRequest(), "/toLogin", "/login/**", "/logout/**", "/login.html", "/oauth/**", "/sms/**", "/captcha/**", "/swagger-ui/**", "/v2/api-docs")) {
                return SecurityConfig.createList("ROLE_NO_LOGIN");
            }
            //根据拦截到的地址去sys_menu中进行匹配，找到菜单并且查看该菜单是否含有权限标识，如果有标识需要验证权限
            String needPermission = adminClient.getPermissionWithUrl(requestUrl);
            if (StringUtils.isNotBlank(needPermission)) {
                //该请求需要XXX权限，那么将该权限保存起来，他将用在AccessDecisionManager类中
                return SecurityConfig.createList(needPermission);
            }

            //如果地址没有找到对应的菜单，先自定义一个权限标识，该标识可以随意，他将用在AccessDecisionManager类中
            return SecurityConfig.createList("ROLE_PASS");
        }

        @Override
        public Collection<ConfigAttribute> getAllConfigAttributes() {
            return null;
        }

        /**
        * 这个方法要先返回true
        */
        @Override
        public boolean supports(Class<?> aClass) {
            return true;
        }

        /**
        * 是否是忽略地址，使用的是Spring自带的URL比较工具类:AntPathMatcher
        */
        public boolean isIgnore(HttpServletRequest request, String... ignorePaths) {
            UrlPathHelper urlPathHelper = new UrlPathHelper();
            String path = urlPathHelper.getLookupPathForRequest(request);
            AntPathMatcher matcher = new AntPathMatcher();
            for (String ignorePath : ignorePaths) {
                if (matcher.match(ignorePath, path)) {
                    return true;
                }
            }
            return false;
        }
    }
    ~~~
    ~~~java
    package com.yongzheng.config.dynamicInterception;

    import org.apache.commons.lang3.StringUtils;
    import org.springframework.security.access.AccessDecisionManager;
    import org.springframework.security.access.AccessDeniedException;
    import org.springframework.security.access.ConfigAttribute;
    import org.springframework.security.authentication.InsufficientAuthenticationException;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.stereotype.Component;

    import java.util.Collection;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/4/25 16:10
    * @description：
    * @modified By：
    * @version:
    */
    @Component
    public class RoleAccessDecisionManager implements AccessDecisionManager {
        @Override
        public void decide(Authentication authentication, Object o, Collection<ConfigAttribute> collection) throws AccessDeniedException, InsufficientAuthenticationException {
            //获取用户所拥有的权限，该权限在登录的时候已经被放入了
            Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
            //接下来就是判定是否存在，如果存在，则return放行
            for (GrantedAuthority authority : authorities) {
                for (ConfigAttribute c : collection) {
                    //如果用户是匿名，也就是说没有登录，ROLE_ANONYMOUS是Security定义的，需要分两种情况，一种是ROLE_NO_LOGIN，这个是MySecurityMetadataSource中自定义的，该标识表示允许匿名访问。另一种情况是需要登录访问
                    if (StringUtils.equals(authority.getAuthority(), "ROLE_ANONYMOUS")) {
                        //只要有ROLE_NO_LOGIN标识，就表示允许匿名访问
                        if (StringUtils.equals(c.getAttribute(), "ROLE_NO_LOGIN")) {
                            return;
                        }
                        //如果没有ROLE_NO_LOGIN的标识表示该地址不允许匿名访问，所以抛出未登录异常
                        throw new InsufficientAuthenticationException("请先登录");
                    }
                    //如果有对应的权限，那么也放行
                    if (c.getAttribute().equals(authority.getAuthority())) {
                        return;
                    }
                    //ROLE_PASS该标识是在FilterInvocationSecurityMetadataSource中自己定义的，这里的意思也就是说如果是该标识，那么则放行，也就是说这个路径下不需要权限，只需要登录即可
                    if (StringUtils.equals(c.getAttribute(), "ROLE_PASS")) {
                        return;
                    }
                }
            }
            //权限不通过则抛出异常，如果自定义的授权失败处理器，那将会执行失败处理器的逻辑，也就是返回的错误信息
            throw new AccessDeniedException("当前访问没有权限");
        }

        /**
        * 返回值更改为true
        */
        @Override
        public boolean supports(ConfigAttribute configAttribute) {
            return true;
        }

        /**
        * 返回值更改为true
        */
        @Override
        public boolean supports(Class<?> aClass) {
            return true;
        }
    }

    ~~~
* 最后在资源服务器的配置中配置即可
    ~~~java
    import com.yongzheng.config.dynamicInterception.MySecurityMetadataSource;
    import com.yongzheng.config.dynamicInterception.RoleAccessDecisionManager;
    import lombok.RequiredArgsConstructor;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.config.annotation.ObjectPostProcessor;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
    import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
    import org.springframework.security.web.access.intercept.FilterSecurityInterceptor;

    /**
    * @author ：liwuming
    * @date ：Created in 2022/6/8 17:19
    * @description ：
    * @modified By：
    * @version:
    */
    @RequiredArgsConstructor
    @Configuration
    public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {

        private final MyExtendAccessDeniedHandler myExtendAccessDeniedHandler;
        private final MyExtendAuthenticationEntryPointHandler myExtendAuthenticationEntryPointHandler;
        private final MySecurityMetadataSource mySecurityMetadataSource;
        private final RoleAccessDecisionManager roleAccessDecisionManager;

        @Override
        public void configure(ResourceServerSecurityConfigurer resources) {
            resources.authenticationEntryPoint(myExtendAuthenticationEntryPointHandler).accessDeniedHandler(myExtendAccessDeniedHandler);
        }

        @Override
        public void configure(HttpSecurity http) throws Exception {
            http.authorizeRequests()
                    // 允许 路径为/code/ 后面为任意信息的路径地址 不需要通过oauth2登录授权
                    .antMatchers("/captcha/**").permitAll()
                    .anyRequest().authenticated()
                    .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {
                        @Override
                        public <O extends FilterSecurityInterceptor> O postProcess(O o) {
                            o.setAccessDecisionManager(roleAccessDecisionManager);
                            o.setSecurityMetadataSource(mySecurityMetadataSource);
                            return o;
                        }
                    });
        }
    }
    ~~~

## Token的失效时间和刷新
* 如果使用的是JDBC的形式，直接改数据库中的access_token_validity字段即可，超级简单
* token的刷新同样是Oauth2提供的，直接截图，这是第一次通过身份验证获取到的数据
    ~~~json
    "data": {
            "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTQ4NDQ3MDgsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsic3lzX21lbnVfZWRpdCIsIlJPTEVf5rWL6K-VMSIsInN5c19yb2xlX2VkaXQiLCJzeXNfcm9sZV9wZXJtIiwic3lzX21lbnVfYWRkIiwic3lzX3JvbGVfYWRkIiwic3lzX3VzZXJfYWRkIiwiUk9MRV9BRE1JTiIsInN5c19tZW51X2RlbCIsInN5c19yb2xlX2RlbCJdLCJqdGkiOiJjMDg0ZTBhMS1kNDAyLTQ0MjAtODNmYi1iZDAyYjY0MTdjM2UiLCJjbGllbnRfaWQiOiJub25hbWUiLCJzY29wZSI6WyJhbGwiXX0.sLq0cFmAOkx7lHjGyw9ImIdOul8ZZOhItALhXufFyEc",
            "token_type": "bearer",
            "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiJjMDg0ZTBhMS1kNDAyLTQ0MjAtODNmYi1iZDAyYjY0MTdjM2UiLCJleHAiOjE2NTc0MzY2OTgsImF1dGhvcml0aWVzIjpbInN5c19tZW51X2VkaXQiLCJST0xFX-a1i-ivlTEiLCJzeXNfcm9sZV9lZGl0Iiwic3lzX3JvbGVfcGVybSIsInN5c19tZW51X2FkZCIsInN5c19yb2xlX2FkZCIsInN5c191c2VyX2FkZCIsIlJPTEVfQURNSU4iLCJzeXNfbWVudV9kZWwiLCJzeXNfcm9sZV9kZWwiXSwianRpIjoiYjE2ZDdlMzEtOGIyMC00NjBhLTllNDUtNzA0ZjNkNDIyN2RjIiwiY2xpZW50X2lkIjoibm9uYW1lIn0.f4m78P4X19U23mJzEnCKMw5laYcruRvj_pkOEKWrdoA",
            "expires_in": 9,
            "scope": "all",
            "jti": "c084e0a1-d402-4420-83fb-bd02b6417c3e"
        }
    ~~~
* 同样的，需要身份验证也就是ClientID和密钥等信息
* ![](./pic/刷新token_身份验证.jpg)
* 然后传递之前的refresh_token字段，和Grant_type
* ![](./pic/刷新token_传参.jpg)
* 返回格式如下
    ~~~json
    "data": {
            "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTQ4NDQ5ODQsInVzZXJfbmFtZSI6ImFkbWluIiwiYXV0aG9yaXRpZXMiOlsic3lzX21lbnVfZWRpdCIsIlJPTEVf5rWL6K-VMSIsInN5c19yb2xlX2VkaXQiLCJzeXNfcm9sZV9wZXJtIiwic3lzX21lbnVfYWRkIiwic3lzX3JvbGVfYWRkIiwic3lzX3VzZXJfYWRkIiwiUk9MRV9BRE1JTiIsInN5c19tZW51X2RlbCIsInN5c19yb2xlX2RlbCJdLCJqdGkiOiI0MGJkODA3My1kY2QwLTQ2NDgtYjU0Yy02Yjc1OTFkZmVmNmQiLCJjbGllbnRfaWQiOiJub25hbWUiLCJzY29wZSI6WyJhbGwiXX0.5VTH0fZGkTLUsumEFdCR0dn1JFOuSaUKjjlwXe1Tt2A",
            "token_type": "bearer",
            "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJhZG1pbiIsInNjb3BlIjpbImFsbCJdLCJhdGkiOiI0MGJkODA3My1kY2QwLTQ2NDgtYjU0Yy02Yjc1OTFkZmVmNmQiLCJleHAiOjE2NTc0MzY2OTgsImF1dGhvcml0aWVzIjpbInN5c19tZW51X2VkaXQiLCJST0xFX-a1i-ivlTEiLCJzeXNfcm9sZV9lZGl0Iiwic3lzX3JvbGVfcGVybSIsInN5c19tZW51X2FkZCIsInN5c19yb2xlX2FkZCIsInN5c191c2VyX2FkZCIsIlJPTEVfQURNSU4iLCJzeXNfbWVudV9kZWwiLCJzeXNfcm9sZV9kZWwiXSwianRpIjoiYjE2ZDdlMzEtOGIyMC00NjBhLTllNDUtNzA0ZjNkNDIyN2RjIiwiY2xpZW50X2lkIjoibm9uYW1lIn0.BfLIIA3Zh07SOAPWrOmSM6wXoO0Be0DyuM6fwaptdKA",
            "expires_in": 10,
            "scope": "all",
            "jti": "40bd8073-dcd0-4648-b54c-6b7591dfef6d"
        }
    ~~~

## 关于WebMvcConfigurerAdapter和ResourceServerConfigurerAdapter的冲突关系
* 也就是总配置和资源服务器配置
* 这两者是存在优先级顺序的，WebMvcConfigurerAdapter的优先级默认是99，而ResourceServerConfigurerAdapter的优先级默认是3，所以在很多时候对于路径的拦截，这两者都是存在冲突的
* 如果想解决这个问题，可以使用 @Order 注解来调整WebMvcConfigurerAdapter的顺序
* 即 @Order(2)

## 退出登录
* 上面提到了资源管理器和总配置是存在冲突的，登出的代码既可以写在资源服务中，也可以写在认证服务中
* 但是从一般角度而言，这个操作就应该是认证服务就做的事情，所以需要将认证服务的总配置文件的优先级调高，即@Order(2)
* 自定义登出的逻辑
    ~~~java
    @Component
    public class CustomLogoutSuccessHandler implements LogoutSuccessHandler {

        @Override
        public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException {
            //由于拦截器的顺序问题，正常来讲在退出拦截器的时候用户的信息还没放入到context中，所以是无法获取用户信息的。
            //当然在网上有方法去重写jwtAuthenticationFilter,然后将它放到LogoutFilter的前面
            //但一般来讲退出我们并不关心用户是谁谁谁，所以其实意义也不大，直接告诉客户退出成功即可
    //        User user = (User) authentication.getPrincipal();
    //        String username = user.getUsername();

            //由于样例采用的是JWT形式的token,其有一个特点：一次签发永久有效，所以无法从服务端来控制token的有效性
            //也就是说，即使用户登出了该token只要还没过期就还能继续使用，解决的方式可以改成Redis保存的方式，然后退出后销毁redis即可
            //此处不考虑这么多，直接返回成功
            responseJsonWriter(httpServletResponse, R.ok());
        }

        private static void responseJsonWriter(HttpServletResponse response, R rest) throws IOException {
            response.setStatus(HttpServletResponse.SC_OK);
            response.setCharacterEncoding("utf-8");
            response.setContentType(MediaType.APPLICATION_JSON_VALUE);
            ObjectMapper objectMapper = new ObjectMapper();
            String resBody = objectMapper.writeValueAsString(rest);
            PrintWriter printWriter = response.getWriter();
            printWriter.print(resBody);
            printWriter.flush();
            printWriter.close();
        }
    }
    ~~~
* 然后直接在WebSecurityConfigurerAdapter中配置即可,当然不要忘记 @Order(2)
    ~~~java
    @Configuration
    @RequiredArgsConstructor(onConstructor = @__(@Autowired))
    @EnableWebSecurity
    @Order(2)
    public class SecurityConfig extends WebSecurityConfigurerAdapter {

        private final UserDetailsService userDetailsService;
        private final CustomLogoutSuccessHandler customLogoutSuccessHandler;

        @Bean
        public PasswordEncoder getPw() {
            return new BCryptPasswordEncoder();
        }

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf().disable().authorizeRequests()
                    .antMatchers("/oauth/**", "/login/**,/logout/**").permitAll()
                    .anyRequest().authenticated()
                    //and()没什么实际意义，只是一个连接符
                    .and()
                    //所有表单都放行
                    .formLogin().permitAll()
                    .and()
                    //自定义登出
                    .logout().logoutUrl("/logout").logoutSuccessHandler(customLogoutSuccessHandler).deleteCookies("Admin-Token","Refresh-Token");
        }


        @Bean
        public CorsFilter corsFilter() {
            UrlBasedCorsConfigurationSource configurationSource = new UrlBasedCorsConfigurationSource();
    //        CorsConfiguration cors = new CorsConfiguration();
    //        cors.setAllowCredentials(true);
    //        cors.addAllowedOriginPattern("*");
    //        cors.addAllowedHeader("*");
    //        cors.addAllowedMethod("*");
    //        configurationSource.registerCorsConfiguration("/**", cors);
            return new CorsFilter(configurationSource);
        }

        @Bean
        @Override
        public AuthenticationManager authenticationManagerBean() throws Exception {
            return super.authenticationManagerBean();
        }
    }
    ~~~