## 官方文档
> https://panjiachen.github.io/vue-element-admin-site/zh/guide/#功能

## 前置环境
* node.js
* git
* python2.7,百度地址：https://pan.baidu.com/s/18wNwB5IkH13kEpG66uJqfA    密码：znaf
* python3.6.6,百度地址：https://pan.baidu.com/link/zhihu/79hWzVuMhMiERnFjNnQr9jlDafZZBzTQUCZ3==   无密码

## 安装
* git clone https://github.com/PanJiaChen/vue-element-admin.git
* cd vue-element-admin
* 必须满足前置环境，python的版本可能不同，如果报错则调整版本
* npm install --registry=https://registry.npm.taobao.org  （此处很有可能报错）
  * 很有可能会报错  git@github.com: Permission denied (publickey)
  * 此时就是没有将git和github等绑定起来
  * 参照该帖子即可 > https://blog.csdn.net/ywl470812087/article/details/104459288,不过该帖子其中一步 ssh-agent -s 有可能不行是因为windows没有启动相关服务造成的，服务的名称为：OpenSSH Authentication Agent。另外需要注意的是不是使用cmd窗口运行指令，而是通过Git Bash去执行，大坑
  * 另外如果报错，提示找不到VS，那么需要切换VS的版本：npm config set msvs_version 2017，最后这个版本是根据电脑中已经安装的版本为主，想要查看电脑中已经存在的版本可以在 已安装程序中搜索 Microsoft Visual C++ 
* 如果没有其他异常则可以直接 npm run dev

## 项目结构
* 直接参看官方文档
* 路由和侧边菜单栏：在src/router/index.js,其中有两个属性，一个是constantRoutes，表示静态路由，asyncRoutes表示异步。如果不需要从后台获取的话直接在asyncRoutes加入即可
  
## 登录改写详解
* 参照 https://blog.csdn.net/qq_40298670/article/details/112705554
* 首先需要定位登录页面，位置是在src/views/login/index.vue，该页面即登录组件
* 如果有验证码的话可以在组件中添加验证码，只贴出局部代码
  ~~~html
  <!--      验证码部分，还未添加点击刷新等事件-->
        <el-form-item>
          <el-input v-model="loginForm.captcha" placeholder="请输入验证码" />
        </el-form-item>
        <!--      验证码的后端地址-->
        <el-form-item>
          <img :src="imgBaseCode" alt="图片加载失败，请点击重试" class="pointer" @click="refreshCode">
        </el-form-item>
        <!--      登录的按钮，这个是框架原来就有的，只要在这上面添加验证码即可-->
        <el-button :loading="loading" type="primary" style="width:100%;margin-bottom:30px;" @click.native.prevent="handleLogin">Login</el-button>
  ~~~
* 点击登录触发的事件是handleLogin，可以找到该函数，如下
  ~~~js
  handleLogin() {
        this.$refs.loginForm.validate(valid => {
          if (valid) {
            this.loading = true
            this.$store.dispatch('user/login', this.loginForm)
              .then(() => {
                this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
                this.loading = false
              })
              .catch(() => {
                this.loading = false
              })
          } else {
            console.log('error submit!!')
            return false
          }
        })
      }
  ~~~
* 在该函数中有一句核心的代码   this.$store.dispatch('user/login', this.loginForm)，该语句实际的逻辑是在src/store/modules/user.js中，核心函数内容如下
  ~~~js
  login({ commit }, userInfo) {
      const { username, password } = userInfo
      return new Promise((resolve, reject) => {
        // 核心代码
        login({ username: username.trim(), password: password }).then(response => {
          const { data } = response
          commit('SET_TOKEN', data.token)
          setToken(data.token)
          resolve()
        }).catch(error => {
          reject(error)
        })
      })
    }
  ~~~
* 如上的login函数中，又内嵌了一个 login({ username: username.trim(), password: password }).then(response => 函数，这个函数是来自于 src/api/user.js 中，可以看到如下内容
  ~~~js
  export function login(data) {
    return request({
      url: '/vue-element-admin/user/login',
      method: 'post',
      data
    })
  }
  ~~~
* 如上这一段即是发送请求，但是它本身也是封装，可以点击跳转后发现，它实际的逻辑是在 src/utils/request.js 中，它的作用是封装了网网络请求，这一段看上去比较复杂，看下面一章的内容详解
* 在默认的情况下，登录是通过mock形式获取的，由于这一段和网上的代码有一些偏差，可以直接查看 mock/user.js,可以看到如下的代码
  ~~~js
  {
      url: '/vue-element-admin/user/login',
      type: 'post',
      response: config => {
        const { username } = config.body
        const token = tokens[username]

        // mock error
        if (!token) {
          return {
            code: 60204,
            message: 'Account and password are incorrect.'
          }
        }

        return {
          code: 20000,
          data: token
        }
      }
  ~~~
* 当然在实际的开发中不可能使用mock,需要一个统一的后台地址，修改.env.development,将VUE_APP_BASE_API = '/dev-api' 修改为自己的后端地址，修改后如下
  ~~~properties
  # just a flag
  ENV = 'development'

  # base api
  VUE_APP_BASE_API = 'http://localhost:9001'
  ~~~
* 配置完成以后要想让该文件生效，还需要在vue.config.js中添加代理，主要修改的内容是devServer中的内容
  ~~~js
  devServer: {
      port: port,
      open: true,
      overlay: {
        warnings: false,
        errors: true
      },
      // 代理配置，需要添加的部分
      proxy: {
        [process.env.VUE_APP_BASE_API]: {
          target: process.env.VUE_APP_BASE_API,
          // 是否跨域
          changeOrigin: true,
          pathRewrite: {
            ['^' + process.env.VUE_APP_BASE_API]: ''
          }
        }
      }
      // 注意原本的mock方式需要注释掉才行
      // before: require('./mock/mock-server.js')
    }
  ~~~
* 修改完成以后需要根据后端的请求路径去更改login的服务地址，由于项目是使用的Spring Security框架，默认的地址就是/login。但使用了gateway网关，所以会涉及到一部分的请求转发，这个需要根据实际的情况决定。前端更改登录地址的路径是在 src/api/user.js中，更改后如下：
  ~~~js
  export function login(data) {
    return request({
      url: '/yz-auth/login',
      method: 'post',
      data
    })
  }
  ~~~
* 但是在很多情况下都是以表单的形式传递参数的，而不是上面的body实体，如果想以表单形式传递，可以写成如下形式
  ~~~js
  export function login(data) {
    return request({
      url: '/yz-auth/login',
      method: 'post',
      params: data
    })
  }
  ~~~
* 如上是由于使用了网关，记得修改完成以后要重启前端项目，此时再去登录，这个时候由于使用了Gateway，大概率会有一个跨域的问题。想要解决的话需要在网关服务中添加跨域的配置，直接上代码
  ~~~java
  @Configuration
  public class CorsConfig {

      @Bean
      public WebFilter corsFilter2() {
          return (ServerWebExchange ctx, WebFilterChain chain) -> {
              ServerHttpRequest request = ctx.getRequest();
              if (CorsUtils.isCorsRequest(request)) {
                  HttpHeaders requestHeaders = request.getHeaders();
                  ServerHttpResponse response = ctx.getResponse();
                  HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod();
                  HttpHeaders headers = response.getHeaders();
                  headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin());
                  headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,
                          requestHeaders.getAccessControlRequestHeaders());
                  if (requestMethod != null) {
                      headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name());
                  }
                  headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
                  headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "*");
                  if (request.getMethod() == HttpMethod.OPTIONS) {
                      response.setStatusCode(HttpStatus.OK);
                      return Mono.empty();
                  }
              }
              return chain.filter(ctx);
          };
      }
  }
  ~~~
* 此时再去访问的话基本就可以调通了，但是之前是添加了验证码的，所以需要将验证码的字段也传递给后端，首先还是要在登录页中修改，在data的loginForm对象中添加一个字段，如下：
  ~~~js
  loginForm: {
          username: 'admin',
          password: '111111',
          captcha: ''
        }
  ~~~
* 然后在 src/store/modules/user.js 中的login函数中添加该传参字段，代码片段如下：
  ~~~js
  login({ commit }, userInfo) {
      const { username, password, captcha } = userInfo
      return new Promise((resolve, reject) => {
        // 将验证码的字段也一起传递给后端
        login({ username: username.trim(), password: password, verifyCode: captcha }).then(response => {
          const { data } = response
          commit('SET_TOKEN', data.token)
          setToken(data.token)
          resolve()
        }).catch(error => {
          reject(error)
        })
      })
    }
  ~~~

## 自封装axios（图形验证码示例）
* 在该框架下，所有的请求都放在 src/api/目录下，以图形验证码为栗子，新建一个common.js
  ~~~js
  // 由于vue-element-admih 已经封装好了axios,即在request.js中，所以我们引入
  import request from '@/utils/request'
  // getCaptcha就是函数名称，当然也是可以传递参数的，此处没有而已。然后就是一些基本属性，注意由于是验证码，所以指定了arraybuffer的返回类型
  // 完整的属性可以查看 https://blog.csdn.net/weixin_42161050/article/details/121475647
  export function getCaptcha() {
    return request({
      url: '/yz-auth/captcha/captchaCode',
      method: 'post',
      responseType: 'arraybuffer'
    })
  }
  ~~~
* 其实这样就可以完成了，但由于验证码的特殊性，返回的是流，所以需要特殊处理，但由于是使用的request.js的代码，需要修改一下,修改的位置是在service.interceptors.response.use 中的 if (res.code !== 200) {的开始处，如下是代码片段
  ~~~js
  // 此处是验证码部分的处理，如果返回的类型是arraybuffer，那么需要特殊处理一下
        const indexs = response.config.responseType
        if (indexs === 'arraybuffer') {
          return 'data:image/png;base64,' + btoa(
            new Uint8Array(res)
              .reduce((data, byte) => data + String.fromCharCode(byte), '')
          )
        }
  ~~~
* 然后就可以使用了，当然需要先导包
  ~~~js
  import { getCaptcha } from '@/api/common'

  getCaptcha()
        .then(data => {
          // doSomething
        })
  ~~~

## 跨域问题
* 前端的跨域其实在配置代理的时候指定可跨域即可
* 主要是后端，后端在使用了网关的情况下，只需要在网关中添加跨域配置，也就是上面提到的网关配置代码
* 如果集成了Spring Security并且有网关，那么不要再去配置Security的跨域，也就是在自定义的WebSecurityConfigurerAdapter类中，注入一个空的corsFilter
  ~~~java
      @Bean
      public CorsFilter corsFilter() {
          UrlBasedCorsConfigurationSource configurationSource = new UrlBasedCorsConfigurationSource();
          return new CorsFilter(configurationSource);
      }
  ~~~