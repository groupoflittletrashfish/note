## 官方文档
> https://panjiachen.github.io/vue-element-admin-site/zh/guide/#功能

## 前置环境
* node.js
* git
* python2.7,百度地址：https://pan.baidu.com/s/18wNwB5IkH13kEpG66uJqfA    密码：znaf
* python3.6.6,百度地址：https://pan.baidu.com/link/zhihu/79hWzVuMhMiERnFjNnQr9jlDafZZBzTQUCZ3==   无密码

## 安装
* git clone https://github.com/PanJiaChen/vue-element-admin.git
* cd vue-element-admin
* 必须满足前置环境，python的版本可能不同，如果报错则调整版本
* npm install --registry=https://registry.npm.taobao.org  （此处很有可能报错）
  * 很有可能会报错  git@github.com: Permission denied (publickey)
  * 此时就是没有将git和github等绑定起来
  * 参照该帖子即可 > https://blog.csdn.net/ywl470812087/article/details/104459288,不过该帖子其中一步 ssh-agent -s 有可能不行是因为windows没有启动相关服务造成的，服务的名称为：OpenSSH Authentication Agent。另外需要注意的是不是使用cmd窗口运行指令，而是通过Git Bash去执行，大坑
  * 另外如果报错，提示找不到VS，那么需要切换VS的版本：npm config set msvs_version 2017，最后这个版本是根据电脑中已经安装的版本为主，想要查看电脑中已经存在的版本可以在 已安装程序中搜索 Microsoft Visual C++ 
* 如果没有其他异常则可以直接 npm run dev

## 项目结构
* 直接参看官方文档
* 路由和侧边菜单栏：在src/router/index.js,其中有两个属性，一个是constantRoutes，表示静态路由，asyncRoutes表示异步。如果不需要从后台获取的话直接在asyncRoutes加入即可
  
## 登录改写详解
* 参照 https://blog.csdn.net/qq_40298670/article/details/112705554
* 首先需要定位登录页面，位置是在src/views/login/index.vue，该页面即登录组件
* 如果有验证码的话可以在组件中添加验证码，只贴出局部代码
  ~~~html
        <!--      验证码部分，还未添加点击刷新等事件-->
        <el-form-item>
          <el-input v-model="loginForm.captcha" placeholder="请输入验证码" />
        </el-form-item>
        <!--      验证码的后端地址-->
        <el-form-item>
          <img src="http://localhost:9000/captcha/captchaCode" alt="图片加载失败，请点击重试" class="pointer">
        </el-form-item>
        <!--      登录的按钮，这个是框架原来就有的，只要在这上面添加验证码即可-->
        <el-button :loading="loading" type="primary" style="width:100%;margin-bottom:30px;" @click.native.prevent="handleLogin">Login</el-button>
  ~~~
* 点击登录触发的事件是handleLogin，可以找到该函数，如下
  ~~~js
  handleLogin() {
        this.$refs.loginForm.validate(valid => {
          if (valid) {
            this.loading = true
            this.$store.dispatch('user/login', this.loginForm)
              .then(() => {
                this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
                this.loading = false
              })
              .catch(() => {
                this.loading = false
              })
          } else {
            console.log('error submit!!')
            return false
          }
        })
      }
  ~~~
* 在该函数中有一句核心的代码   this.$store.dispatch('user/login', this.loginForm)，该语句实际的逻辑是在src/store/modules/user.js中，核心函数内容如下
  ~~~js
  login({ commit }, userInfo) {
      const { username, password } = userInfo
      return new Promise((resolve, reject) => {
        // 核心代码
        login({ username: username.trim(), password: password }).then(response => {
          const { data } = response
          commit('SET_TOKEN', data.token)
          setToken(data.token)
          resolve()
        }).catch(error => {
          reject(error)
        })
      })
    }
  ~~~
* 如上的login函数中，又内嵌了一个 login({ username: username.trim(), password: password }).then(response => 函数，这个函数是来自于 src/api/user.js 中，可以看到如下内容
  ~~~js
  export function login(data) {
    return request({
      url: '/vue-element-admin/user/login',
      method: 'post',
      data
    })
  }
  ~~~
* 如上这一段即是发送请求，但是它本身也是封装，可以点击跳转后发现，它实际的逻辑是在 src/utils/request.js 中，它的作用是封装了网网络请求，这一段看上去比较复杂，看下面一章的内容详解
* 在默认的情况下，登录是通过mock形式获取的，由于这一段和网上的代码有一些偏差，可以直接查看 mock/user.js,可以看到如下的代码
  ~~~js
  {
      url: '/vue-element-admin/user/login',
      type: 'post',
      response: config => {
        const { username } = config.body
        const token = tokens[username]

        // mock error
        if (!token) {
          return {
            code: 60204,
            message: 'Account and password are incorrect.'
          }
        }

        return {
          code: 20000,
          data: token
        }
      }
  ~~~
* 当然在实际的开发中不可能使用mock,需要一个统一的后台地址，修改.env.development,将VUE_APP_BASE_API = '/dev-api' 修改为自己的后端地址，修改后如下
  ~~~properties
  # just a flag
  ENV = 'development'

  # base api
  VUE_APP_BASE_API = 'http://localhost:9001'
  ~~~
* 配置完成以后要想让该文件生效，还需要在vue.config.js中添加代理，主要修改的内容是devServer中的内容
  ~~~js
  devServer: {
      port: port,
      open: true,
      overlay: {
        warnings: false,
        errors: true
      },
      // 代理配置，需要添加的部分
      proxy: {
        [process.env.VUE_APP_BASE_API]: {
          target: process.env.VUE_APP_BASE_API,
          // 是否跨域
          changeOrigin: true,
          pathRewrite: {
            ['^' + process.env.VUE_APP_BASE_API]: ''
          }
        }
      }
      // 注意原本的mock方式需要注释掉才行
      // before: require('./mock/mock-server.js')
    }
  ~~~
* 修改完成以后需要根据后端的请求路径去更改login的服务地址，由于项目是使用的Spring Security框架，默认的地址就是/login。但使用了gateway网关，所以会涉及到一部分的请求转发，这个需要根据实际的情况决定。前端更改登录地址的路径是在 src/api/user.js中，更改后如下：
  ~~~js
  export function login(data) {
    return request({
      url: '/yz-auth/login',
      method: 'post',
      data
    })
  }
  ~~~
* 如上是由于使用了网关，记得修改完成以后要重启前端项目，此时再去登录，这个时候由于使用了Gateway，大概率会有一个跨域的问题。想要解决的话需要在网关服务中添加跨域的配置，直接上代码
  ~~~java
  @Configuration
  public class CorsConfig {

      @Bean
      public WebFilter corsFilter2() {
          return (ServerWebExchange ctx, WebFilterChain chain) -> {
              ServerHttpRequest request = ctx.getRequest();
              if (CorsUtils.isCorsRequest(request)) {
                  HttpHeaders requestHeaders = request.getHeaders();
                  ServerHttpResponse response = ctx.getResponse();
                  HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod();
                  HttpHeaders headers = response.getHeaders();
                  headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin());
                  headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS,
                          requestHeaders.getAccessControlRequestHeaders());
                  if (requestMethod != null) {
                      headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name());
                  }
                  headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
                  headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "*");
                  if (request.getMethod() == HttpMethod.OPTIONS) {
                      response.setStatusCode(HttpStatus.OK);
                      return Mono.empty();
                  }
              }
              return chain.filter(ctx);
          };
      }
  }
  ~~~

## request.js详解
* 该文件是在src/utils/request.js 
* 